About the StompMessagingProtocol interface and its conflict with the messaging protocol. You can use it and change the server code in the relevant places to make the signatures fit. Or you can change the MessagingProtocol to match the need for the StompMessagingProtocol and then you don't need to change the server classes signatures.
    A channel (topic) is created in the server the first time a client tries to subscribe to it.
    You will need to write an encoder-decoder of your own for the type of message received in the stomp communication. this should be fairly straight forward, as you already have the LineMessageEncoderDecoder at your disposal, which decodes and encodes a single line. The difference in your case is that the delimiter is the null character rather then the line separator character.
    You will need to make some changes to the code in srv in order to make it work with the new protocol interface (and maybe other interfaces). This may break the examples we gave you for server and client implementations (provided in the impl folder) but this is expected. The changes needed are small, if you find yourself rewriting the entire server code you are probably doing something wrong.
    The Connections object should be the used for sending messages to different clients from the protocol. It has 2 main sending methods you need to implement, one for sending a message to a single client and one for sending a message to a topic, that is, to a list of clients that's subscribed to that topic. In addition, we tasked you with implementing the send() method in the connection handlers. This method should be called from the send() methods of the Connection objects in order to use the connection handler to send messages to the clients they represent.
    In the server side, you should start by implementing the protocol and the encoder and decoder. In general, what you need to do in the server side is implement the protocol and encoder decoder for STOMP so that they can serialize and process the messages from the client, and use the Connections object as mentioned above to send the frames you need to send to the clients you need to send them to.
    The team's names in the evnts1_partial.json and evnts1.json were not the same. the fixed version is added here and in the v3 of the code.
    The encoder-decoder implementations do not need to be generic on T, they should be implementations on some type (of your choosing) of the generic interfaces. In each of the examples we gave you, the classes that hold and use the protocol and encoder-decoder are referring to the generic interfaces, but the implementations of those interfaces are on a specific type.
    When a user disconnects from the system, the server should keep the username and the password so that a client can log into it at a later time. The subscriptions, however, should be deleted for this user.
    You may change the interfaces you are required to implement as you see fit. That is, you can add methods or change existing method signatures. That being said, don't move any of the protocol logic out of the protocol. (Thus, you are not required to use the send() method with channel if it does not work with your implementation).
    You can assume the events in the json will appear in the order of their time.
    We removed the requirement to deal with the two flags of before_halftime and is_active as they are no longer needed in the assignment. If you implemented the client with them, you can leave them as they are and assume they will be there, if not, you can ignore them.
    A suggested(!) data structure for saving the reports on the client side:
    A data structure example for saving game information.

Orange: a hash-map from game_name to user_name_map
Green: a hash-map from user_name to a Game object.
Blue: a Game object containing all the information received from the reports from user_name on the game_name channel.
Summary command - When the summary command is invoked, what you need to write to the file is simply the content of the Game object mapped to the given user_name under the given game_name (in the format defined in the assignment).